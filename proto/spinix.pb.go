// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/spinix.proto

package proto

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Rule struct {
	RuleId     string   `protobuf:"bytes,1,opt,name=rule_id,json=ruleId,proto3" json:"rule_id,omitempty"`
	Spec       string   `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec,omitempty"`
	RegionIds  []string `protobuf:"bytes,3,rep,name=region_ids,json=regionIds,proto3" json:"region_ids,omitempty"`
	RegionSize int64    `protobuf:"varint,4,opt,name=region_size,json=regionSize,proto3" json:"region_size,omitempty"`
}

func (m *Rule) Reset()      { *m = Rule{} }
func (*Rule) ProtoMessage() {}
func (*Rule) Descriptor() ([]byte, []int) {
	return fileDescriptor_e3318ce1f17c4927, []int{0}
}
func (m *Rule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Rule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Rule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rule.Merge(m, src)
}
func (m *Rule) XXX_Size() int {
	return m.Size()
}
func (m *Rule) XXX_DiscardUnknown() {
	xxx_messageInfo_Rule.DiscardUnknown(m)
}

var xxx_messageInfo_Rule proto.InternalMessageInfo

func (m *Rule) GetRuleId() string {
	if m != nil {
		return m.RuleId
	}
	return ""
}

func (m *Rule) GetSpec() string {
	if m != nil {
		return m.Spec
	}
	return ""
}

func (m *Rule) GetRegionIds() []string {
	if m != nil {
		return m.RegionIds
	}
	return nil
}

func (m *Rule) GetRegionSize() int64 {
	if m != nil {
		return m.RegionSize
	}
	return 0
}

type Device struct {
	Imei          string  `protobuf:"bytes,1,opt,name=imei,proto3" json:"imei,omitempty"`
	Owner         string  `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	Brand         string  `protobuf:"bytes,3,opt,name=brand,proto3" json:"brand,omitempty"`
	Model         string  `protobuf:"bytes,4,opt,name=model,proto3" json:"model,omitempty"`
	Latitude      float32 `protobuf:"fixed32,5,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude     float32 `protobuf:"fixed32,6,opt,name=longitude,proto3" json:"longitude,omitempty"`
	Altitude      float32 `protobuf:"fixed32,7,opt,name=altitude,proto3" json:"altitude,omitempty"`
	Speed         float32 `protobuf:"fixed32,8,opt,name=speed,proto3" json:"speed,omitempty"`
	DateTime      int64   `protobuf:"varint,9,opt,name=date_time,json=dateTime,proto3" json:"date_time,omitempty"`
	Status        int64   `protobuf:"varint,10,opt,name=status,proto3" json:"status,omitempty"`
	BatteryCharge float32 `protobuf:"fixed32,11,opt,name=battery_charge,json=batteryCharge,proto3" json:"battery_charge,omitempty"`
	Temperature   float32 `protobuf:"fixed32,12,opt,name=temperature,proto3" json:"temperature,omitempty"`
	Humidity      float32 `protobuf:"fixed32,13,opt,name=humidity,proto3" json:"humidity,omitempty"`
	Luminosity    float32 `protobuf:"fixed32,14,opt,name=luminosity,proto3" json:"luminosity,omitempty"`
	Pressure      float32 `protobuf:"fixed32,15,opt,name=pressure,proto3" json:"pressure,omitempty"`
	FuelLevel     float32 `protobuf:"fixed32,16,opt,name=fuel_level,json=fuelLevel,proto3" json:"fuel_level,omitempty"`
}

func (m *Device) Reset()      { *m = Device{} }
func (*Device) ProtoMessage() {}
func (*Device) Descriptor() ([]byte, []int) {
	return fileDescriptor_e3318ce1f17c4927, []int{1}
}
func (m *Device) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Device) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Device.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Device) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Device.Merge(m, src)
}
func (m *Device) XXX_Size() int {
	return m.Size()
}
func (m *Device) XXX_DiscardUnknown() {
	xxx_messageInfo_Device.DiscardUnknown(m)
}

var xxx_messageInfo_Device proto.InternalMessageInfo

func (m *Device) GetImei() string {
	if m != nil {
		return m.Imei
	}
	return ""
}

func (m *Device) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *Device) GetBrand() string {
	if m != nil {
		return m.Brand
	}
	return ""
}

func (m *Device) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *Device) GetLatitude() float32 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *Device) GetLongitude() float32 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *Device) GetAltitude() float32 {
	if m != nil {
		return m.Altitude
	}
	return 0
}

func (m *Device) GetSpeed() float32 {
	if m != nil {
		return m.Speed
	}
	return 0
}

func (m *Device) GetDateTime() int64 {
	if m != nil {
		return m.DateTime
	}
	return 0
}

func (m *Device) GetStatus() int64 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *Device) GetBatteryCharge() float32 {
	if m != nil {
		return m.BatteryCharge
	}
	return 0
}

func (m *Device) GetTemperature() float32 {
	if m != nil {
		return m.Temperature
	}
	return 0
}

func (m *Device) GetHumidity() float32 {
	if m != nil {
		return m.Humidity
	}
	return 0
}

func (m *Device) GetLuminosity() float32 {
	if m != nil {
		return m.Luminosity
	}
	return 0
}

func (m *Device) GetPressure() float32 {
	if m != nil {
		return m.Pressure
	}
	return 0
}

func (m *Device) GetFuelLevel() float32 {
	if m != nil {
		return m.FuelLevel
	}
	return 0
}

type Object struct {
	Id      string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	GeoJson string `protobuf:"bytes,2,opt,name=geo_json,json=geoJson,proto3" json:"geo_json,omitempty"`
}

func (m *Object) Reset()      { *m = Object{} }
func (*Object) ProtoMessage() {}
func (*Object) Descriptor() ([]byte, []int) {
	return fileDescriptor_e3318ce1f17c4927, []int{2}
}
func (m *Object) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Object) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Object.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Object) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Object.Merge(m, src)
}
func (m *Object) XXX_Size() int {
	return m.Size()
}
func (m *Object) XXX_DiscardUnknown() {
	xxx_messageInfo_Object.DiscardUnknown(m)
}

var xxx_messageInfo_Object proto.InternalMessageInfo

func (m *Object) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Object) GetGeoJson() string {
	if m != nil {
		return m.GeoJson
	}
	return ""
}

type Match struct {
	Left       *Decl  `protobuf:"bytes,2,opt,name=left,proto3" json:"left,omitempty"`
	Right      *Decl  `protobuf:"bytes,3,opt,name=right,proto3" json:"right,omitempty"`
	OperatorId int64  `protobuf:"varint,4,opt,name=operator_id,json=operatorId,proto3" json:"operator_id,omitempty"`
	Operator   string `protobuf:"bytes,5,opt,name=operator,proto3" json:"operator,omitempty"`
	Pos        int64  `protobuf:"varint,6,opt,name=pos,proto3" json:"pos,omitempty"`
}

func (m *Match) Reset()      { *m = Match{} }
func (*Match) ProtoMessage() {}
func (*Match) Descriptor() ([]byte, []int) {
	return fileDescriptor_e3318ce1f17c4927, []int{3}
}
func (m *Match) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Match) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Match.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Match) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Match.Merge(m, src)
}
func (m *Match) XXX_Size() int {
	return m.Size()
}
func (m *Match) XXX_DiscardUnknown() {
	xxx_messageInfo_Match.DiscardUnknown(m)
}

var xxx_messageInfo_Match proto.InternalMessageInfo

func (m *Match) GetLeft() *Decl {
	if m != nil {
		return m.Left
	}
	return nil
}

func (m *Match) GetRight() *Decl {
	if m != nil {
		return m.Right
	}
	return nil
}

func (m *Match) GetOperatorId() int64 {
	if m != nil {
		return m.OperatorId
	}
	return 0
}

func (m *Match) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *Match) GetPos() int64 {
	if m != nil {
		return m.Pos
	}
	return 0
}

type Event struct {
	Id       string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Device   *Device  `protobuf:"bytes,2,opt,name=device,proto3" json:"device,omitempty"`
	DateTime int64    `protobuf:"varint,3,opt,name=date_time,json=dateTime,proto3" json:"date_time,omitempty"`
	Rule     *Rule    `protobuf:"bytes,4,opt,name=rule,proto3" json:"rule,omitempty"`
	Match    []*Match `protobuf:"bytes,5,rep,name=match,proto3" json:"match,omitempty"`
}

func (m *Event) Reset()      { *m = Event{} }
func (*Event) ProtoMessage() {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_e3318ce1f17c4927, []int{4}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Event) GetDevice() *Device {
	if m != nil {
		return m.Device
	}
	return nil
}

func (m *Event) GetDateTime() int64 {
	if m != nil {
		return m.DateTime
	}
	return 0
}

func (m *Event) GetRule() *Rule {
	if m != nil {
		return m.Rule
	}
	return nil
}

func (m *Event) GetMatch() []*Match {
	if m != nil {
		return m.Match
	}
	return nil
}

type Decl struct {
	KeywordId int64    `protobuf:"varint,1,opt,name=keyword_id,json=keywordId,proto3" json:"keyword_id,omitempty"`
	Keyword   string   `protobuf:"bytes,2,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Refs      []string `protobuf:"bytes,3,rep,name=refs,proto3" json:"refs,omitempty"`
}

func (m *Decl) Reset()      { *m = Decl{} }
func (*Decl) ProtoMessage() {}
func (*Decl) Descriptor() ([]byte, []int) {
	return fileDescriptor_e3318ce1f17c4927, []int{5}
}
func (m *Decl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Decl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Decl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Decl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Decl.Merge(m, src)
}
func (m *Decl) XXX_Size() int {
	return m.Size()
}
func (m *Decl) XXX_DiscardUnknown() {
	xxx_messageInfo_Decl.DiscardUnknown(m)
}

var xxx_messageInfo_Decl proto.InternalMessageInfo

func (m *Decl) GetKeywordId() int64 {
	if m != nil {
		return m.KeywordId
	}
	return 0
}

func (m *Decl) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *Decl) GetRefs() []string {
	if m != nil {
		return m.Refs
	}
	return nil
}

type DetectRequest struct {
	Device *Device `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
}

func (m *DetectRequest) Reset()      { *m = DetectRequest{} }
func (*DetectRequest) ProtoMessage() {}
func (*DetectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e3318ce1f17c4927, []int{6}
}
func (m *DetectRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DetectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DetectRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DetectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectRequest.Merge(m, src)
}
func (m *DetectRequest) XXX_Size() int {
	return m.Size()
}
func (m *DetectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DetectRequest proto.InternalMessageInfo

func (m *DetectRequest) GetDevice() *Device {
	if m != nil {
		return m.Device
	}
	return nil
}

type DetectReply struct {
	Ok    bool     `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
	Event []*Event `protobuf:"bytes,2,rep,name=event,proto3" json:"event,omitempty"`
	Error *Error   `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *DetectReply) Reset()      { *m = DetectReply{} }
func (*DetectReply) ProtoMessage() {}
func (*DetectReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_e3318ce1f17c4927, []int{7}
}
func (m *DetectReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DetectReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DetectReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DetectReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectReply.Merge(m, src)
}
func (m *DetectReply) XXX_Size() int {
	return m.Size()
}
func (m *DetectReply) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectReply.DiscardUnknown(m)
}

var xxx_messageInfo_DetectReply proto.InternalMessageInfo

func (m *DetectReply) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *DetectReply) GetEvent() []*Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *DetectReply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type ObjectRequest struct {
	Object *Object `protobuf:"bytes,1,opt,name=object,proto3" json:"object,omitempty"`
}

func (m *ObjectRequest) Reset()      { *m = ObjectRequest{} }
func (*ObjectRequest) ProtoMessage() {}
func (*ObjectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e3318ce1f17c4927, []int{8}
}
func (m *ObjectRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectRequest.Merge(m, src)
}
func (m *ObjectRequest) XXX_Size() int {
	return m.Size()
}
func (m *ObjectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectRequest proto.InternalMessageInfo

func (m *ObjectRequest) GetObject() *Object {
	if m != nil {
		return m.Object
	}
	return nil
}

type DeviceRequest struct {
	Device *Device `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
}

func (m *DeviceRequest) Reset()      { *m = DeviceRequest{} }
func (*DeviceRequest) ProtoMessage() {}
func (*DeviceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e3318ce1f17c4927, []int{9}
}
func (m *DeviceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceRequest.Merge(m, src)
}
func (m *DeviceRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeviceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceRequest proto.InternalMessageInfo

func (m *DeviceRequest) GetDevice() *Device {
	if m != nil {
		return m.Device
	}
	return nil
}

type Reply struct {
	Error *Error `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *Reply) Reset()      { *m = Reply{} }
func (*Reply) ProtoMessage() {}
func (*Reply) Descriptor() ([]byte, []int) {
	return fileDescriptor_e3318ce1f17c4927, []int{10}
}
func (m *Reply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Reply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Reply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Reply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reply.Merge(m, src)
}
func (m *Reply) XXX_Size() int {
	return m.Size()
}
func (m *Reply) XXX_DiscardUnknown() {
	xxx_messageInfo_Reply.DiscardUnknown(m)
}

var xxx_messageInfo_Reply proto.InternalMessageInfo

func (m *Reply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type RuleRequest struct {
	Spec string `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
}

func (m *RuleRequest) Reset()      { *m = RuleRequest{} }
func (*RuleRequest) ProtoMessage() {}
func (*RuleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e3318ce1f17c4927, []int{11}
}
func (m *RuleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RuleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RuleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuleRequest.Merge(m, src)
}
func (m *RuleRequest) XXX_Size() int {
	return m.Size()
}
func (m *RuleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RuleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RuleRequest proto.InternalMessageInfo

func (m *RuleRequest) GetSpec() string {
	if m != nil {
		return m.Spec
	}
	return ""
}

type RuleReply struct {
	Rule  *Rule  `protobuf:"bytes,1,opt,name=rule,proto3" json:"rule,omitempty"`
	Error *Error `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *RuleReply) Reset()      { *m = RuleReply{} }
func (*RuleReply) ProtoMessage() {}
func (*RuleReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_e3318ce1f17c4927, []int{12}
}
func (m *RuleReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuleReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RuleReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RuleReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuleReply.Merge(m, src)
}
func (m *RuleReply) XXX_Size() int {
	return m.Size()
}
func (m *RuleReply) XXX_DiscardUnknown() {
	xxx_messageInfo_RuleReply.DiscardUnknown(m)
}

var xxx_messageInfo_RuleReply proto.InternalMessageInfo

func (m *RuleReply) GetRule() *Rule {
	if m != nil {
		return m.Rule
	}
	return nil
}

func (m *RuleReply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type Error struct {
	Code int64  `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg  string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *Error) Reset()      { *m = Error{} }
func (*Error) ProtoMessage() {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_e3318ce1f17c4927, []int{13}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(m, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Error) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func init() {
	proto.RegisterType((*Rule)(nil), "proto.Rule")
	proto.RegisterType((*Device)(nil), "proto.Device")
	proto.RegisterType((*Object)(nil), "proto.Object")
	proto.RegisterType((*Match)(nil), "proto.Match")
	proto.RegisterType((*Event)(nil), "proto.Event")
	proto.RegisterType((*Decl)(nil), "proto.Decl")
	proto.RegisterType((*DetectRequest)(nil), "proto.DetectRequest")
	proto.RegisterType((*DetectReply)(nil), "proto.DetectReply")
	proto.RegisterType((*ObjectRequest)(nil), "proto.ObjectRequest")
	proto.RegisterType((*DeviceRequest)(nil), "proto.DeviceRequest")
	proto.RegisterType((*Reply)(nil), "proto.Reply")
	proto.RegisterType((*RuleRequest)(nil), "proto.RuleRequest")
	proto.RegisterType((*RuleReply)(nil), "proto.RuleReply")
	proto.RegisterType((*Error)(nil), "proto.Error")
}

func init() { proto.RegisterFile("proto/spinix.proto", fileDescriptor_e3318ce1f17c4927) }

var fileDescriptor_e3318ce1f17c4927 = []byte{
	// 790 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0x4f, 0x6f, 0xdc, 0x44,
	0x14, 0x5f, 0xaf, 0xd7, 0x9b, 0xf5, 0xdb, 0x26, 0x54, 0x23, 0x04, 0xe6, 0x9f, 0xb3, 0xb5, 0x54,
	0x69, 0x25, 0x44, 0x91, 0x5a, 0xc4, 0x07, 0x80, 0x70, 0x08, 0x02, 0x81, 0xa6, 0xdc, 0x57, 0xce,
	0xfa, 0x65, 0x33, 0x8d, 0xed, 0x59, 0x66, 0xc6, 0x29, 0xe9, 0x89, 0x8f, 0xc0, 0x99, 0x13, 0x47,
	0xbe, 0x05, 0x57, 0x8e, 0x39, 0xf6, 0x48, 0x36, 0x17, 0x8e, 0xfd, 0x08, 0xe8, 0xbd, 0x19, 0x6f,
	0xd2, 0xa0, 0x46, 0xea, 0xc9, 0xf3, 0xfb, 0xfd, 0xde, 0x9b, 0xf7, 0x77, 0x0c, 0x62, 0x6d, 0xb4,
	0xd3, 0x9f, 0xdb, 0xb5, 0x6a, 0xd5, 0x2f, 0x8f, 0x18, 0x88, 0x84, 0x3f, 0x85, 0x85, 0x91, 0xec,
	0x6a, 0x14, 0xef, 0xc3, 0x8e, 0xe9, 0x6a, 0x5c, 0xa8, 0x2a, 0x8b, 0x66, 0xd1, 0x3c, 0x95, 0x63,
	0x82, 0x87, 0x95, 0x10, 0x30, 0xb2, 0x6b, 0x5c, 0x66, 0x43, 0x66, 0xf9, 0x2c, 0x3e, 0x01, 0x30,
	0xb8, 0x52, 0xba, 0x5d, 0xa8, 0xca, 0x66, 0xf1, 0x2c, 0x9e, 0xa7, 0x32, 0xf5, 0xcc, 0x61, 0x65,
	0xc5, 0x3e, 0x4c, 0x83, 0x6c, 0xd5, 0x0b, 0xcc, 0x46, 0xb3, 0x68, 0x1e, 0xcb, 0xe0, 0xf1, 0x54,
	0xbd, 0xc0, 0xe2, 0xaf, 0x18, 0xc6, 0x07, 0x78, 0xa6, 0x96, 0x48, 0xd7, 0xab, 0x06, 0x55, 0x08,
	0xca, 0x67, 0xf1, 0x2e, 0x24, 0xfa, 0x79, 0x8b, 0x26, 0xc4, 0xf4, 0x80, 0xd8, 0x23, 0x53, 0xb6,
	0x55, 0x16, 0x7b, 0x96, 0x01, 0xb1, 0x8d, 0xae, 0xb0, 0xe6, 0x28, 0xa9, 0xf4, 0x40, 0x7c, 0x08,
	0x93, 0xba, 0x74, 0xca, 0x75, 0x15, 0x66, 0xc9, 0x2c, 0x9a, 0x0f, 0xe5, 0x16, 0x8b, 0x8f, 0x21,
	0xad, 0x75, 0xbb, 0xf2, 0xe2, 0x98, 0xc5, 0x6b, 0x82, 0x3c, 0xcb, 0x3a, 0x78, 0xee, 0x78, 0xcf,
	0x1e, 0x53, 0x2c, 0xbb, 0x46, 0xac, 0xb2, 0x09, 0x0b, 0x1e, 0x88, 0x8f, 0x20, 0xad, 0x4a, 0x87,
	0x0b, 0xa7, 0x1a, 0xcc, 0x52, 0xae, 0x75, 0x42, 0xc4, 0x4f, 0xaa, 0x41, 0xf1, 0x1e, 0x8c, 0xad,
	0x2b, 0x5d, 0x67, 0x33, 0x60, 0x25, 0x20, 0xf1, 0x10, 0xf6, 0x8e, 0x4a, 0xe7, 0xd0, 0x9c, 0x2f,
	0x96, 0x27, 0xa5, 0x59, 0x61, 0x36, 0xe5, 0x3b, 0x77, 0x03, 0xfb, 0x35, 0x93, 0x62, 0x06, 0x53,
	0x87, 0xcd, 0x1a, 0x4d, 0xe9, 0x3a, 0x83, 0xd9, 0x3d, 0xb6, 0xb9, 0x49, 0x51, 0xbe, 0x27, 0x5d,
	0xa3, 0x2a, 0xe5, 0xce, 0xb3, 0x5d, 0x9f, 0x6f, 0x8f, 0x45, 0x0e, 0x50, 0x77, 0x8d, 0x6a, 0xb5,
	0x25, 0x75, 0x8f, 0xd5, 0x1b, 0x0c, 0xf9, 0xae, 0x0d, 0x5a, 0x4b, 0x57, 0xbf, 0xe3, 0x7d, 0x7b,
	0x4c, 0x23, 0x3e, 0xee, 0xb0, 0x5e, 0xd4, 0x78, 0x86, 0x75, 0x76, 0xdf, 0xb7, 0x89, 0x98, 0xef,
	0x88, 0x28, 0x9e, 0xc0, 0xf8, 0x87, 0xa3, 0x67, 0xb8, 0x74, 0x62, 0x0f, 0x86, 0xdb, 0x9d, 0x19,
	0xaa, 0x4a, 0x7c, 0x00, 0x93, 0x15, 0xea, 0xc5, 0x33, 0xab, 0xdb, 0x30, 0xbf, 0x9d, 0x15, 0xea,
	0x6f, 0xad, 0x6e, 0x8b, 0xdf, 0x23, 0x48, 0xbe, 0x2f, 0xdd, 0xf2, 0x44, 0xec, 0xc3, 0xa8, 0xc6,
	0x63, 0xc7, 0x06, 0xd3, 0xc7, 0x53, 0xbf, 0x92, 0x8f, 0x0e, 0x70, 0x59, 0x4b, 0x16, 0xc4, 0x03,
	0x48, 0x8c, 0x5a, 0x9d, 0x38, 0x1e, 0xf6, 0x2d, 0x0b, 0xaf, 0xd0, 0x96, 0x69, 0x6e, 0x83, 0x36,
	0xb4, 0xb5, 0x61, 0xcb, 0x7a, 0xea, 0xb0, 0xa2, 0xf2, 0x7a, 0xc4, 0x4b, 0x90, 0xca, 0x2d, 0x16,
	0xf7, 0x21, 0x5e, 0x6b, 0xcb, 0xe3, 0x8f, 0x25, 0x1d, 0x8b, 0x3f, 0x22, 0x48, 0xbe, 0x39, 0xc3,
	0xf6, 0xff, 0x15, 0x3d, 0x84, 0x71, 0xc5, 0xcb, 0x1a, 0xd2, 0xdd, 0xdd, 0x26, 0x43, 0xa4, 0x0c,
	0xe2, 0xeb, 0x7b, 0x10, 0xdf, 0xda, 0x83, 0x7d, 0x18, 0xd1, 0x7b, 0xe2, 0x2c, 0xaf, 0xcb, 0xa1,
	0x97, 0x27, 0x59, 0x10, 0x05, 0x24, 0x0d, 0xb5, 0x26, 0x4b, 0x66, 0xf1, 0x7c, 0xfa, 0xf8, 0x5e,
	0xb0, 0xe0, 0x76, 0x49, 0x2f, 0x15, 0x4f, 0x61, 0x44, 0x0d, 0xa0, 0xd9, 0x9c, 0xe2, 0xf9, 0x73,
	0x6d, 0xaa, 0xfe, 0xb9, 0xc6, 0x32, 0x0d, 0xcc, 0x61, 0x25, 0x32, 0xd8, 0x09, 0xa0, 0x1f, 0x40,
	0x80, 0xf4, 0xd8, 0x0c, 0x1e, 0xf7, 0x2f, 0x96, 0xcf, 0xc5, 0x97, 0xb0, 0x7b, 0x80, 0x0e, 0x97,
	0x4e, 0xe2, 0xcf, 0x1d, 0x5a, 0x77, 0xa3, 0xdc, 0xe8, 0x8e, 0x72, 0x0b, 0x84, 0x69, 0xef, 0xb7,
	0xae, 0xcf, 0xa9, 0x69, 0xfa, 0x94, 0x3d, 0x26, 0x72, 0xa8, 0x4f, 0xa9, 0x1e, 0xa4, 0x6e, 0x66,
	0xc3, 0xd7, 0xea, 0xe1, 0x0e, 0x4b, 0x2f, 0xb1, 0x8d, 0x31, 0xda, 0x84, 0x21, 0x6f, 0x6d, 0x88,
	0x93, 0x5e, 0xa2, 0xf4, 0xfc, 0xa2, 0xdd, 0x48, 0x4f, 0x33, 0x71, 0x2b, 0xbd, 0x60, 0x15, 0x44,
	0x5f, 0x16, 0x27, 0xfc, 0x76, 0x65, 0x7d, 0x0a, 0x89, 0x2f, 0x68, 0x9b, 0x5c, 0xf4, 0xe6, 0xe4,
	0x1e, 0xc0, 0x94, 0x47, 0x18, 0x42, 0xf4, 0xbf, 0xca, 0xe8, 0xfa, 0x57, 0x59, 0xfc, 0x08, 0xa9,
	0x37, 0xa1, 0x3b, 0xfb, 0x2d, 0x88, 0xee, 0xd8, 0x02, 0x1f, 0x74, 0xf8, 0xe6, 0xa0, 0x9f, 0x41,
	0xc2, 0x98, 0xc2, 0x2d, 0x75, 0x85, 0x61, 0x01, 0xf8, 0x4c, 0x7b, 0xdd, 0xd8, 0x55, 0x98, 0x3b,
	0x1d, 0xbf, 0xfa, 0xe2, 0xe2, 0x32, 0x1f, 0xbc, 0xbc, 0xcc, 0x07, 0xaf, 0x2e, 0xf3, 0xe8, 0xd7,
	0x4d, 0x1e, 0xfd, 0xb9, 0xc9, 0xa3, 0xbf, 0x37, 0x79, 0x74, 0xb1, 0xc9, 0xa3, 0x7f, 0x36, 0x79,
	0xf4, 0xef, 0x26, 0x1f, 0xbc, 0xda, 0xe4, 0xd1, 0x6f, 0x57, 0xf9, 0xe0, 0xe2, 0x2a, 0x1f, 0xbc,
	0xbc, 0xca, 0x07, 0x47, 0x63, 0x0e, 0xfc, 0xe4, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf2, 0xf9,
	0xeb, 0x20, 0x3a, 0x06, 0x00, 0x00,
}

func (this *Rule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Rule)
	if !ok {
		that2, ok := that.(Rule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RuleId != that1.RuleId {
		return false
	}
	if this.Spec != that1.Spec {
		return false
	}
	if len(this.RegionIds) != len(that1.RegionIds) {
		return false
	}
	for i := range this.RegionIds {
		if this.RegionIds[i] != that1.RegionIds[i] {
			return false
		}
	}
	if this.RegionSize != that1.RegionSize {
		return false
	}
	return true
}
func (this *Device) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Device)
	if !ok {
		that2, ok := that.(Device)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Imei != that1.Imei {
		return false
	}
	if this.Owner != that1.Owner {
		return false
	}
	if this.Brand != that1.Brand {
		return false
	}
	if this.Model != that1.Model {
		return false
	}
	if this.Latitude != that1.Latitude {
		return false
	}
	if this.Longitude != that1.Longitude {
		return false
	}
	if this.Altitude != that1.Altitude {
		return false
	}
	if this.Speed != that1.Speed {
		return false
	}
	if this.DateTime != that1.DateTime {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.BatteryCharge != that1.BatteryCharge {
		return false
	}
	if this.Temperature != that1.Temperature {
		return false
	}
	if this.Humidity != that1.Humidity {
		return false
	}
	if this.Luminosity != that1.Luminosity {
		return false
	}
	if this.Pressure != that1.Pressure {
		return false
	}
	if this.FuelLevel != that1.FuelLevel {
		return false
	}
	return true
}
func (this *Object) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Object)
	if !ok {
		that2, ok := that.(Object)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.GeoJson != that1.GeoJson {
		return false
	}
	return true
}
func (this *Match) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Match)
	if !ok {
		that2, ok := that.(Match)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Left.Equal(that1.Left) {
		return false
	}
	if !this.Right.Equal(that1.Right) {
		return false
	}
	if this.OperatorId != that1.OperatorId {
		return false
	}
	if this.Operator != that1.Operator {
		return false
	}
	if this.Pos != that1.Pos {
		return false
	}
	return true
}
func (this *Event) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Event)
	if !ok {
		that2, ok := that.(Event)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if !this.Device.Equal(that1.Device) {
		return false
	}
	if this.DateTime != that1.DateTime {
		return false
	}
	if !this.Rule.Equal(that1.Rule) {
		return false
	}
	if len(this.Match) != len(that1.Match) {
		return false
	}
	for i := range this.Match {
		if !this.Match[i].Equal(that1.Match[i]) {
			return false
		}
	}
	return true
}
func (this *Decl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Decl)
	if !ok {
		that2, ok := that.(Decl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.KeywordId != that1.KeywordId {
		return false
	}
	if this.Keyword != that1.Keyword {
		return false
	}
	if len(this.Refs) != len(that1.Refs) {
		return false
	}
	for i := range this.Refs {
		if this.Refs[i] != that1.Refs[i] {
			return false
		}
	}
	return true
}
func (this *DetectRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DetectRequest)
	if !ok {
		that2, ok := that.(DetectRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Device.Equal(that1.Device) {
		return false
	}
	return true
}
func (this *DetectReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DetectReply)
	if !ok {
		that2, ok := that.(DetectReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ok != that1.Ok {
		return false
	}
	if len(this.Event) != len(that1.Event) {
		return false
	}
	for i := range this.Event {
		if !this.Event[i].Equal(that1.Event[i]) {
			return false
		}
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (this *ObjectRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ObjectRequest)
	if !ok {
		that2, ok := that.(ObjectRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Object.Equal(that1.Object) {
		return false
	}
	return true
}
func (this *DeviceRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeviceRequest)
	if !ok {
		that2, ok := that.(DeviceRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Device.Equal(that1.Device) {
		return false
	}
	return true
}
func (this *Reply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Reply)
	if !ok {
		that2, ok := that.(Reply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (this *RuleRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RuleRequest)
	if !ok {
		that2, ok := that.(RuleRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Spec != that1.Spec {
		return false
	}
	return true
}
func (this *RuleReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RuleReply)
	if !ok {
		that2, ok := that.(RuleReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Rule.Equal(that1.Rule) {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (this *Error) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Error)
	if !ok {
		that2, ok := that.(Error)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Msg != that1.Msg {
		return false
	}
	return true
}
func (this *Rule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&proto.Rule{")
	s = append(s, "RuleId: "+fmt.Sprintf("%#v", this.RuleId)+",\n")
	s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	s = append(s, "RegionIds: "+fmt.Sprintf("%#v", this.RegionIds)+",\n")
	s = append(s, "RegionSize: "+fmt.Sprintf("%#v", this.RegionSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Device) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 20)
	s = append(s, "&proto.Device{")
	s = append(s, "Imei: "+fmt.Sprintf("%#v", this.Imei)+",\n")
	s = append(s, "Owner: "+fmt.Sprintf("%#v", this.Owner)+",\n")
	s = append(s, "Brand: "+fmt.Sprintf("%#v", this.Brand)+",\n")
	s = append(s, "Model: "+fmt.Sprintf("%#v", this.Model)+",\n")
	s = append(s, "Latitude: "+fmt.Sprintf("%#v", this.Latitude)+",\n")
	s = append(s, "Longitude: "+fmt.Sprintf("%#v", this.Longitude)+",\n")
	s = append(s, "Altitude: "+fmt.Sprintf("%#v", this.Altitude)+",\n")
	s = append(s, "Speed: "+fmt.Sprintf("%#v", this.Speed)+",\n")
	s = append(s, "DateTime: "+fmt.Sprintf("%#v", this.DateTime)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "BatteryCharge: "+fmt.Sprintf("%#v", this.BatteryCharge)+",\n")
	s = append(s, "Temperature: "+fmt.Sprintf("%#v", this.Temperature)+",\n")
	s = append(s, "Humidity: "+fmt.Sprintf("%#v", this.Humidity)+",\n")
	s = append(s, "Luminosity: "+fmt.Sprintf("%#v", this.Luminosity)+",\n")
	s = append(s, "Pressure: "+fmt.Sprintf("%#v", this.Pressure)+",\n")
	s = append(s, "FuelLevel: "+fmt.Sprintf("%#v", this.FuelLevel)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Object) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto.Object{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "GeoJson: "+fmt.Sprintf("%#v", this.GeoJson)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Match) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&proto.Match{")
	if this.Left != nil {
		s = append(s, "Left: "+fmt.Sprintf("%#v", this.Left)+",\n")
	}
	if this.Right != nil {
		s = append(s, "Right: "+fmt.Sprintf("%#v", this.Right)+",\n")
	}
	s = append(s, "OperatorId: "+fmt.Sprintf("%#v", this.OperatorId)+",\n")
	s = append(s, "Operator: "+fmt.Sprintf("%#v", this.Operator)+",\n")
	s = append(s, "Pos: "+fmt.Sprintf("%#v", this.Pos)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Event) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&proto.Event{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	if this.Device != nil {
		s = append(s, "Device: "+fmt.Sprintf("%#v", this.Device)+",\n")
	}
	s = append(s, "DateTime: "+fmt.Sprintf("%#v", this.DateTime)+",\n")
	if this.Rule != nil {
		s = append(s, "Rule: "+fmt.Sprintf("%#v", this.Rule)+",\n")
	}
	if this.Match != nil {
		s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Decl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proto.Decl{")
	s = append(s, "KeywordId: "+fmt.Sprintf("%#v", this.KeywordId)+",\n")
	s = append(s, "Keyword: "+fmt.Sprintf("%#v", this.Keyword)+",\n")
	s = append(s, "Refs: "+fmt.Sprintf("%#v", this.Refs)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DetectRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto.DetectRequest{")
	if this.Device != nil {
		s = append(s, "Device: "+fmt.Sprintf("%#v", this.Device)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DetectReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proto.DetectReply{")
	s = append(s, "Ok: "+fmt.Sprintf("%#v", this.Ok)+",\n")
	if this.Event != nil {
		s = append(s, "Event: "+fmt.Sprintf("%#v", this.Event)+",\n")
	}
	if this.Error != nil {
		s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ObjectRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto.ObjectRequest{")
	if this.Object != nil {
		s = append(s, "Object: "+fmt.Sprintf("%#v", this.Object)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeviceRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto.DeviceRequest{")
	if this.Device != nil {
		s = append(s, "Device: "+fmt.Sprintf("%#v", this.Device)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Reply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto.Reply{")
	if this.Error != nil {
		s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RuleRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto.RuleRequest{")
	s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RuleReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto.RuleReply{")
	if this.Rule != nil {
		s = append(s, "Rule: "+fmt.Sprintf("%#v", this.Rule)+",\n")
	}
	if this.Error != nil {
		s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Error) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto.Error{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Msg: "+fmt.Sprintf("%#v", this.Msg)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringSpinix(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Rule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RegionSize != 0 {
		i = encodeVarintSpinix(dAtA, i, uint64(m.RegionSize))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RegionIds) > 0 {
		for iNdEx := len(m.RegionIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RegionIds[iNdEx])
			copy(dAtA[i:], m.RegionIds[iNdEx])
			i = encodeVarintSpinix(dAtA, i, uint64(len(m.RegionIds[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Spec) > 0 {
		i -= len(m.Spec)
		copy(dAtA[i:], m.Spec)
		i = encodeVarintSpinix(dAtA, i, uint64(len(m.Spec)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RuleId) > 0 {
		i -= len(m.RuleId)
		copy(dAtA[i:], m.RuleId)
		i = encodeVarintSpinix(dAtA, i, uint64(len(m.RuleId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Device) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Device) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Device) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FuelLevel != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.FuelLevel))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x85
	}
	if m.Pressure != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Pressure))))
		i--
		dAtA[i] = 0x7d
	}
	if m.Luminosity != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Luminosity))))
		i--
		dAtA[i] = 0x75
	}
	if m.Humidity != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Humidity))))
		i--
		dAtA[i] = 0x6d
	}
	if m.Temperature != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Temperature))))
		i--
		dAtA[i] = 0x65
	}
	if m.BatteryCharge != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.BatteryCharge))))
		i--
		dAtA[i] = 0x5d
	}
	if m.Status != 0 {
		i = encodeVarintSpinix(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x50
	}
	if m.DateTime != 0 {
		i = encodeVarintSpinix(dAtA, i, uint64(m.DateTime))
		i--
		dAtA[i] = 0x48
	}
	if m.Speed != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Speed))))
		i--
		dAtA[i] = 0x45
	}
	if m.Altitude != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Altitude))))
		i--
		dAtA[i] = 0x3d
	}
	if m.Longitude != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Longitude))))
		i--
		dAtA[i] = 0x35
	}
	if m.Latitude != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Latitude))))
		i--
		dAtA[i] = 0x2d
	}
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintSpinix(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Brand) > 0 {
		i -= len(m.Brand)
		copy(dAtA[i:], m.Brand)
		i = encodeVarintSpinix(dAtA, i, uint64(len(m.Brand)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintSpinix(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Imei) > 0 {
		i -= len(m.Imei)
		copy(dAtA[i:], m.Imei)
		i = encodeVarintSpinix(dAtA, i, uint64(len(m.Imei)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Object) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Object) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Object) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GeoJson) > 0 {
		i -= len(m.GeoJson)
		copy(dAtA[i:], m.GeoJson)
		i = encodeVarintSpinix(dAtA, i, uint64(len(m.GeoJson)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintSpinix(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Match) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Match) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Match) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pos != 0 {
		i = encodeVarintSpinix(dAtA, i, uint64(m.Pos))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintSpinix(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x2a
	}
	if m.OperatorId != 0 {
		i = encodeVarintSpinix(dAtA, i, uint64(m.OperatorId))
		i--
		dAtA[i] = 0x20
	}
	if m.Right != nil {
		{
			size, err := m.Right.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpinix(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Left != nil {
		{
			size, err := m.Left.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpinix(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Match) > 0 {
		for iNdEx := len(m.Match) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Match[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpinix(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Rule != nil {
		{
			size, err := m.Rule.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpinix(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.DateTime != 0 {
		i = encodeVarintSpinix(dAtA, i, uint64(m.DateTime))
		i--
		dAtA[i] = 0x18
	}
	if m.Device != nil {
		{
			size, err := m.Device.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpinix(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintSpinix(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Decl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Decl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Decl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Refs) > 0 {
		for iNdEx := len(m.Refs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Refs[iNdEx])
			copy(dAtA[i:], m.Refs[iNdEx])
			i = encodeVarintSpinix(dAtA, i, uint64(len(m.Refs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Keyword) > 0 {
		i -= len(m.Keyword)
		copy(dAtA[i:], m.Keyword)
		i = encodeVarintSpinix(dAtA, i, uint64(len(m.Keyword)))
		i--
		dAtA[i] = 0x12
	}
	if m.KeywordId != 0 {
		i = encodeVarintSpinix(dAtA, i, uint64(m.KeywordId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DetectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetectRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DetectRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Device != nil {
		{
			size, err := m.Device.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpinix(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DetectReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetectReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DetectReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpinix(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Event) > 0 {
		for iNdEx := len(m.Event) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Event[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpinix(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Ok {
		i--
		if m.Ok {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ObjectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Object != nil {
		{
			size, err := m.Object.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpinix(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeviceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Device != nil {
		{
			size, err := m.Device.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpinix(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Reply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Reply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpinix(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RuleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RuleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Spec) > 0 {
		i -= len(m.Spec)
		copy(dAtA[i:], m.Spec)
		i = encodeVarintSpinix(dAtA, i, uint64(len(m.Spec)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RuleReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RuleReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpinix(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Rule != nil {
		{
			size, err := m.Rule.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpinix(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintSpinix(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintSpinix(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintSpinix(dAtA []byte, offset int, v uint64) int {
	offset -= sovSpinix(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Rule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RuleId)
	if l > 0 {
		n += 1 + l + sovSpinix(uint64(l))
	}
	l = len(m.Spec)
	if l > 0 {
		n += 1 + l + sovSpinix(uint64(l))
	}
	if len(m.RegionIds) > 0 {
		for _, s := range m.RegionIds {
			l = len(s)
			n += 1 + l + sovSpinix(uint64(l))
		}
	}
	if m.RegionSize != 0 {
		n += 1 + sovSpinix(uint64(m.RegionSize))
	}
	return n
}

func (m *Device) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Imei)
	if l > 0 {
		n += 1 + l + sovSpinix(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovSpinix(uint64(l))
	}
	l = len(m.Brand)
	if l > 0 {
		n += 1 + l + sovSpinix(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovSpinix(uint64(l))
	}
	if m.Latitude != 0 {
		n += 5
	}
	if m.Longitude != 0 {
		n += 5
	}
	if m.Altitude != 0 {
		n += 5
	}
	if m.Speed != 0 {
		n += 5
	}
	if m.DateTime != 0 {
		n += 1 + sovSpinix(uint64(m.DateTime))
	}
	if m.Status != 0 {
		n += 1 + sovSpinix(uint64(m.Status))
	}
	if m.BatteryCharge != 0 {
		n += 5
	}
	if m.Temperature != 0 {
		n += 5
	}
	if m.Humidity != 0 {
		n += 5
	}
	if m.Luminosity != 0 {
		n += 5
	}
	if m.Pressure != 0 {
		n += 5
	}
	if m.FuelLevel != 0 {
		n += 6
	}
	return n
}

func (m *Object) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovSpinix(uint64(l))
	}
	l = len(m.GeoJson)
	if l > 0 {
		n += 1 + l + sovSpinix(uint64(l))
	}
	return n
}

func (m *Match) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Left != nil {
		l = m.Left.Size()
		n += 1 + l + sovSpinix(uint64(l))
	}
	if m.Right != nil {
		l = m.Right.Size()
		n += 1 + l + sovSpinix(uint64(l))
	}
	if m.OperatorId != 0 {
		n += 1 + sovSpinix(uint64(m.OperatorId))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovSpinix(uint64(l))
	}
	if m.Pos != 0 {
		n += 1 + sovSpinix(uint64(m.Pos))
	}
	return n
}

func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovSpinix(uint64(l))
	}
	if m.Device != nil {
		l = m.Device.Size()
		n += 1 + l + sovSpinix(uint64(l))
	}
	if m.DateTime != 0 {
		n += 1 + sovSpinix(uint64(m.DateTime))
	}
	if m.Rule != nil {
		l = m.Rule.Size()
		n += 1 + l + sovSpinix(uint64(l))
	}
	if len(m.Match) > 0 {
		for _, e := range m.Match {
			l = e.Size()
			n += 1 + l + sovSpinix(uint64(l))
		}
	}
	return n
}

func (m *Decl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeywordId != 0 {
		n += 1 + sovSpinix(uint64(m.KeywordId))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovSpinix(uint64(l))
	}
	if len(m.Refs) > 0 {
		for _, s := range m.Refs {
			l = len(s)
			n += 1 + l + sovSpinix(uint64(l))
		}
	}
	return n
}

func (m *DetectRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Device != nil {
		l = m.Device.Size()
		n += 1 + l + sovSpinix(uint64(l))
	}
	return n
}

func (m *DetectReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ok {
		n += 2
	}
	if len(m.Event) > 0 {
		for _, e := range m.Event {
			l = e.Size()
			n += 1 + l + sovSpinix(uint64(l))
		}
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovSpinix(uint64(l))
	}
	return n
}

func (m *ObjectRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovSpinix(uint64(l))
	}
	return n
}

func (m *DeviceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Device != nil {
		l = m.Device.Size()
		n += 1 + l + sovSpinix(uint64(l))
	}
	return n
}

func (m *Reply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovSpinix(uint64(l))
	}
	return n
}

func (m *RuleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Spec)
	if l > 0 {
		n += 1 + l + sovSpinix(uint64(l))
	}
	return n
}

func (m *RuleReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rule != nil {
		l = m.Rule.Size()
		n += 1 + l + sovSpinix(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovSpinix(uint64(l))
	}
	return n
}

func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovSpinix(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovSpinix(uint64(l))
	}
	return n
}

func sovSpinix(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSpinix(x uint64) (n int) {
	return sovSpinix(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Rule) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Rule{`,
		`RuleId:` + fmt.Sprintf("%v", this.RuleId) + `,`,
		`Spec:` + fmt.Sprintf("%v", this.Spec) + `,`,
		`RegionIds:` + fmt.Sprintf("%v", this.RegionIds) + `,`,
		`RegionSize:` + fmt.Sprintf("%v", this.RegionSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Device) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Device{`,
		`Imei:` + fmt.Sprintf("%v", this.Imei) + `,`,
		`Owner:` + fmt.Sprintf("%v", this.Owner) + `,`,
		`Brand:` + fmt.Sprintf("%v", this.Brand) + `,`,
		`Model:` + fmt.Sprintf("%v", this.Model) + `,`,
		`Latitude:` + fmt.Sprintf("%v", this.Latitude) + `,`,
		`Longitude:` + fmt.Sprintf("%v", this.Longitude) + `,`,
		`Altitude:` + fmt.Sprintf("%v", this.Altitude) + `,`,
		`Speed:` + fmt.Sprintf("%v", this.Speed) + `,`,
		`DateTime:` + fmt.Sprintf("%v", this.DateTime) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`BatteryCharge:` + fmt.Sprintf("%v", this.BatteryCharge) + `,`,
		`Temperature:` + fmt.Sprintf("%v", this.Temperature) + `,`,
		`Humidity:` + fmt.Sprintf("%v", this.Humidity) + `,`,
		`Luminosity:` + fmt.Sprintf("%v", this.Luminosity) + `,`,
		`Pressure:` + fmt.Sprintf("%v", this.Pressure) + `,`,
		`FuelLevel:` + fmt.Sprintf("%v", this.FuelLevel) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Object) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Object{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`GeoJson:` + fmt.Sprintf("%v", this.GeoJson) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Match) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Match{`,
		`Left:` + strings.Replace(this.Left.String(), "Decl", "Decl", 1) + `,`,
		`Right:` + strings.Replace(this.Right.String(), "Decl", "Decl", 1) + `,`,
		`OperatorId:` + fmt.Sprintf("%v", this.OperatorId) + `,`,
		`Operator:` + fmt.Sprintf("%v", this.Operator) + `,`,
		`Pos:` + fmt.Sprintf("%v", this.Pos) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Event) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMatch := "[]*Match{"
	for _, f := range this.Match {
		repeatedStringForMatch += strings.Replace(f.String(), "Match", "Match", 1) + ","
	}
	repeatedStringForMatch += "}"
	s := strings.Join([]string{`&Event{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Device:` + strings.Replace(this.Device.String(), "Device", "Device", 1) + `,`,
		`DateTime:` + fmt.Sprintf("%v", this.DateTime) + `,`,
		`Rule:` + strings.Replace(this.Rule.String(), "Rule", "Rule", 1) + `,`,
		`Match:` + repeatedStringForMatch + `,`,
		`}`,
	}, "")
	return s
}
func (this *Decl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Decl{`,
		`KeywordId:` + fmt.Sprintf("%v", this.KeywordId) + `,`,
		`Keyword:` + fmt.Sprintf("%v", this.Keyword) + `,`,
		`Refs:` + fmt.Sprintf("%v", this.Refs) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DetectRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DetectRequest{`,
		`Device:` + strings.Replace(this.Device.String(), "Device", "Device", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DetectReply) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForEvent := "[]*Event{"
	for _, f := range this.Event {
		repeatedStringForEvent += strings.Replace(f.String(), "Event", "Event", 1) + ","
	}
	repeatedStringForEvent += "}"
	s := strings.Join([]string{`&DetectReply{`,
		`Ok:` + fmt.Sprintf("%v", this.Ok) + `,`,
		`Event:` + repeatedStringForEvent + `,`,
		`Error:` + strings.Replace(this.Error.String(), "Error", "Error", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ObjectRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ObjectRequest{`,
		`Object:` + strings.Replace(this.Object.String(), "Object", "Object", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeviceRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeviceRequest{`,
		`Device:` + strings.Replace(this.Device.String(), "Device", "Device", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Reply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Reply{`,
		`Error:` + strings.Replace(this.Error.String(), "Error", "Error", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RuleRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RuleRequest{`,
		`Spec:` + fmt.Sprintf("%v", this.Spec) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RuleReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RuleReply{`,
		`Rule:` + strings.Replace(this.Rule.String(), "Rule", "Rule", 1) + `,`,
		`Error:` + strings.Replace(this.Error.String(), "Error", "Error", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Error) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Error{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`Msg:` + fmt.Sprintf("%v", this.Msg) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringSpinix(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpinix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionIds = append(m.RegionIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionSize", wireType)
			}
			m.RegionSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSpinix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpinix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Device) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpinix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Device: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Device: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imei", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Imei = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Brand", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Brand = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Latitude = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Longitude = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Altitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Altitude = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Speed = float32(math.Float32frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateTime", wireType)
			}
			m.DateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatteryCharge", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.BatteryCharge = float32(math.Float32frombits(v))
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temperature", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Temperature = float32(math.Float32frombits(v))
		case 13:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Humidity", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Humidity = float32(math.Float32frombits(v))
		case 14:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Luminosity", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Luminosity = float32(math.Float32frombits(v))
		case 15:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pressure", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Pressure = float32(math.Float32frombits(v))
		case 16:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuelLevel", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.FuelLevel = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipSpinix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpinix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Object) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpinix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Object: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Object: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeoJson = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpinix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpinix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Match) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpinix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Left == nil {
				m.Left = &Decl{}
			}
			if err := m.Left.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Right == nil {
				m.Right = &Decl{}
			}
			if err := m.Right.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorId", wireType)
			}
			m.OperatorId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperatorId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSpinix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpinix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpinix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Device == nil {
				m.Device = &Device{}
			}
			if err := m.Device.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateTime", wireType)
			}
			m.DateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rule == nil {
				m.Rule = &Rule{}
			}
			if err := m.Rule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Match = append(m.Match, &Match{})
			if err := m.Match[len(m.Match)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpinix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpinix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Decl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpinix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Decl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Decl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeywordId", wireType)
			}
			m.KeywordId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeywordId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Refs = append(m.Refs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpinix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpinix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpinix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Device == nil {
				m.Device = &Device{}
			}
			if err := m.Device.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpinix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpinix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetectReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpinix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetectReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetectReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Event = append(m.Event, &Event{})
			if err := m.Event[len(m.Event)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpinix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpinix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpinix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Object{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpinix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpinix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpinix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Device == nil {
				m.Device = &Device{}
			}
			if err := m.Device.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpinix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpinix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpinix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpinix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpinix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpinix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpinix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpinix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpinix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rule == nil {
				m.Rule = &Rule{}
			}
			if err := m.Rule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpinix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpinix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpinix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpinix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpinix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpinix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpinix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSpinix(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSpinix
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpinix
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSpinix
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSpinix
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSpinix
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSpinix        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSpinix          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSpinix = fmt.Errorf("proto: unexpected end of group")
)
